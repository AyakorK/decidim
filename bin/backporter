#!/usr/bin/env ruby
# frozen_string_literal: true

require "byebug"
require "json"
require "English"

# rubocop:disable Style/GlobalVars

$github_token = ARGV[0]
$version_number = ARGV[1]
$pull_request_id = ARGV[2]

if $github_token.nil? || $version_number.nil? || $pull_request_id.nil? || $github_token == "--help"
  puts <<~HELP
    Decidim's backporter. It backports a given PR to the specified version number.

    ## Example

        bin/backporter <GITHUB PERSONAL ACCESS TOKEN> <VERSION NUMBER> <PULL REQUEST ID>

    ## Params

    The <GITHUB PERSONAL ACCESS TOKEN> can be obtained from https://github.com/settings/tokens/new
    You'll need to create one with `public_repo` access.

    The <PULL REQUEST ID> is the id of the pull request that you want to make the backport from.
    It should have the "type: fix" label.

    The <VERSION NUMBER> is the version number that you want to do the backport to.
    It must have the format MAJOR.MINOR.

    ## Explanation

    This script will generate a new PR backporting a given PR.
  HELP

  exit 1
end

def get_data_for_pr(id)
  uri = "https://api.github.com/repos/decidim/decidim/issues/#{id}"
  response = `curl -s -H "Authorization: token #{$github_token}" "#{uri}"`
  JSON.parse(response)
end

def get_pr_data(id)
  data = get_data_for_pr(id)
  labels = data["labels"].map { |l| l["name"] }.sort
  title = data["title"]

  {
    id: id,
    title: title,
    labels: labels,
    type: labels.select { |l| l.match(/^type: /) || l == "target: developer-experience" },
    modules: labels.select { |l| l.match(/^module: /) }
  }
end

def get_sha_commit_from_pr(id)
  commit = `git log --format=oneline | grep "##{id}"`
  commit.split.first
end

def checkout_develop
  `git checkout develop`
end

def create_backport_branch!(commit_sha, branch_title)
  `git checkout release/#{$version_number}-stable`
  `git checkout -b backport/#{branch_title}`
  puts "Cherrypicking commit #{commit_sha}"
  `git cherry-pick #{commit_sha}`
  unless $CHILD_STATUS.exitstatus.zero?
    puts "Resolve the cherrypick conflict manually and exit your shell to keep with the process."
    system ENV.fetch("SHELL")
  end
  if `git diff backport/#{branch_title}..release/#{$version_number}-stable`.empty?
    exit_with_errors("Nothing to push to remote server. It was probably merged already or the cherry-pick was aborted.")
  else
    puts "Pushing branch backport/#{branch_title} to origin"
    `git push origin backport/#{branch_title}`
  end
end

def create_backport_pr!(pr_title, pr_labels)
  puts "Creating the PR in GitHub"
  `gh pr create --title "Backport '#{pr_title}' to v#{$version_number}" \
    --body  "#### :tophat: What? Why?\n\nBackport ##{$pull_request_id} to v#{$version_number}\n\n:hearts: Thank you!" \
    --base release/#{$version_number}-stable \
    --label \"#{(pr_labels << "backport").join(",")}\"`
end

def slugify(string)
  string.downcase.strip.gsub(" ", "-").gsub(/[^\w-]/, "")
end

def exit_if_unstaged_changes
  return if `git diff`.empty?

  exit_with_errors("There are changes not staged in your project. Please commit your changes or stash them.")
end

def exit_with_errors(message)
  puts message
  checkout_develop
  exit 1
end

exit_if_unstaged_changes

commit_sha = get_sha_commit_from_pr($pull_request_id)
pr_data = get_pr_data($pull_request_id)
branch_title = "#{slugify(pr_data[:title]).slice!(0, 30)}-#{pr_data[:id]}"

checkout_develop
create_backport_branch!(commit_sha, branch_title)
create_backport_pr!(pr_data[:title], pr_data[:labels])
checkout_develop
# rubocop:enable Style/GlobalVars
